 * Maeve version 0 release 0 簡易マニュアル
     2008-11-10
     written by Theoria Laevateinn ( http://d.hatena.ne.jp/scinfaxi/ )

 ** これは何であるか？

私 Theoria が、誇大妄想気味な理想を掲げて開発している Scheme コンパイラの最初の・実験的な・言語処理系開発者向けの、リリースです。

現在のところ、対応アーキテクチャは x86-64 の 64bit モードのみで、まともな最適化も何一つありません。機能も整数演算と関数呼び出し程度しかサポートしていません。一応チューリング完全ですが、どう考えても非実用的です。本当にありがとうございました。

今回の版は、基本設計や Maeve 内部における抽象化を御披露目しようというものであって、私のいう「強力な言語処理系」のリリースはまだ先のことです。将来的には他のアーキテクチャにも対応する予定ですし、機能と最適化も十分強化するつもりです。テストやベンチマークも準備します。まあ、このファイルを読んでいるあなたは私のことをよく知っているはずなので、ロードマップなど言うまでもないでしょう。

 ** 何に依存するか？

-適当なバージョンの gcc (アセンブラ/リンカとして利用している)

-Gauche ( Maeve の記述に使っている)

-x86-64 または amd64 と呼ばれるアーキテクチャの 64bit モード
--その他のモードや i386 には対応していません。
---他のモードと i386 への対応は compiler/back-end.scm と compiler/arch.scm をイジれば簡単にできるでしょうから、使いたい人に任せます :-)

-graphviz (フローグラフの可視化)
--Maeve のデバッグを行わない方には必要ないでしょう。 -d または --debug オプションをつけて実行すると、必要になります。

-Scheme 処理系を自作できる程度の実力と根気
--とても実験的で不安定なので、ちょっと遊ぶだけでも難しいということです。

 ** インストール/設定

注意 : 展開後に出来るディレクトリの名前をイジらないで下さい。正常に実行されなくなってしまいます。
注意 : スクリプトの実行は必ず例のように user-driver.scm のあるディレクトリで行ってください。細かなファイルパスの依存関係が残っているのです。

以下のように、ファイルを展開し、 Gauche 用プリコンパイラを走らせて下さい。

 $ tar zxvf Maeve-*.tar.gz
 $ cd maeve
 $ gosh scripts/make-so-gauche-module.scm

プリコンパイルには私のマシン( Core2Duo 2.7GHz )で3分程度かかります。セッティングはこれのみです。あとは適当なディレクトリに配置すれば、インストール完了です。展開後に作成されるディレクトリの最初の階層にある "maeve" というファイルが、ユーザー用のドライバとなっています。

 ** 使い方

 example にアッカーマン関数の例があるので、それを走らせてみましょう :

 $ ./maeve example/ack.scm
 $ ./ack

あなたの環境で、うまく実行されることを祈っています。

 ** ライセンス

「修正 BSD 」とだけ言っておきます。長々とした英文を転載したいとは思わないので。

一応書いておきましょう :
  Copyright (c) 2008, Theoria Laevateinn , All Rights Reserved.

 ** 言語処理系開発者向けの解説

 *** ハックしたい人へのアドバイス

-中間形式のダンプには il:pp/ss debug:il:pp/ss il:pp debug:il:pp などの関数がおすすめです。
-フローグラフの構造をチェックしたい場合、 il->graphviz* を使って下さい。

 *** ファイルとディレクトリの構造
そんなにたくさんないので、まずは find . で一覧を見てみるとよいかと思います。一応解説しておきましょう。
./example : 「コンパイル/実行可能である」ことが保証されたプログラムが入っています。
./for-others : 他の処理系向けの機能テストが入ってます。削除するのが面倒なので、入れたままリリースすることにします。
./lib/gauche : Gauche 用のライブラリが入っているディレクトリです。解説は特に興味深いものだけにとどめておきます。
./lib/gauche/match-map-tree.scm : リストによる木構造の写像です。実際には map というより fold に近いのですが。
./lib/gauche/graph.scm : ハッシュテーブルによるグラフライブラリ。まだ Maeve 本体はこれに依存していません。
./lib/gauche/complex-iterator.scm : 最初の設定時に生成されるスタブファイルです。手書きなので削除しないこと。 ./scripts ディレクトリも参照のこと。
./lib/gauche/ultra-iterator.scm : complex-iterator の後継として開発中のライブラリ。まだ Maeve 本体はこれに依存していません。
./lib/gauche/pp.scm : 共有構造記法を有する pretty printer 。グローバルテーブルも利用可能。
./lib/maeve : Maeve 用のライブラリが入っているディレクトリです
./lib/maeve/arithmetic.scm : 算術演算の為のスタブファイル。現在あるライブラリはこれだけです。
./scripts : インストール時に実行すべきスクリプトの類を入れています。
./scripts/make-so-gauche-module.scm : complex-iterator-original.scm をプリコンパイルし、 complex-iterator.so を作成します。
./scripts/gencomp : Gauche 本体からコピーしたものです。最初のプリコンパイル時に不具合があるようでしたら、これをお使いのバージョンの Gauche のそれと差し替えて、再挑戦するとよいでしょう。
./scripts/complex-iterator-original.scm : complex-iterator の本体かつソースコード。
./scripts/complex-iterator.so : プリコンパイル済み complex-iterator 。 ./lib/gauche/complex-iterator.scm から dynamic-load される。
./tmp : 一時ファイルを保管します。特にデバッグオプションを付けて実行した場合、ここにコンパイル途中の結果が大量に突っ込まれることでしょう。
./compiler : Maeve のコア。
./compiler/middle-end.scm : Gauche によって read されたS式を MIR (中間言語の名前)に変換し、正規化を行います。
./compiler/back-end.scm : MIR の構文水準を低くし、正規化し、アセンブリを生成します。
./compiler/intermediate-language-util.scm : Maeve の全てを支えている「中間言語抽象化層」です。これをメンテナンスしていると気がおかしくなりそうです。読まない方がよいでしょう。
./compiler/intermediate-language-instance.scm : intermediate-language-util のインスタンス。実際の中間言語( MIR )が定義されています。
./compiler/macroexpand.scm : 簡単なマクロ展開子ですが、現在は使っていません(マクロ未実装ゆえ)。
./compiler/file-definitions.scm : 出力ファイルの定義。
./compiler/arch.scm : アーキテクチャのパラメタ化の試み。
./compiler/maeve-driver.scm : middle-end や back-end で定義されている変換子を呼び出す内部ドライバ。
./prototype : 実験的なコードを入れています。
./user-driver.scm : ユーザー向けのドライバ。 maeve-driver の唯一の利用者。
./maeve : Gauche に -A オプションを付加し、 user-driver を呼ぶだけのシェルスクリプト。
./README.ja : 本ファイル。
./gdbx : gdb 用の初期化ファイル。ブレークポイントと実行の指示のみ。 Maeve のバグを追いかけたい人用。

 *** コールスタックの構造

注意 : http://d.hatena.ne.jp/scinfaxi/20081108/1226115764 から転載されたもの。

まず現在の Maeve における引数とローカル変数のアロケーションは pluggable である。ここでいう「アロケーション」とは lvar や result なる抽象実体から register やスタック参照のような具象実体への置換であって、中水準から低水準への構文水準変換において行われる。当該構文水準変換はトップレベル定義された関数である。 pluggable とは「『アロケーションを行うもの』、つまり『アロケーター』を引数として受け取る」ということである。

アロケーターは「レジスタ割り当て」と「引数割り当て」の二種類ある。「レジスタ割り当て((現状では「レジスタ割り当て」は「名ばかり」であり、全ての lvar に対して、適切なスタック参照を対応させる。つまり、レジスタを一切使用しない。))」は「引数割り当て」と、構文水準変換前の式と共に、構文水準変換の先頭で呼ばれる((fast call を採用する場合、引数をレジスタに優先的に割り当てる必要がある。よって、レジスタ割り当ては引数割り当ての結果に依存する。))。「レジスタ割り当て」は特殊なオブジェクトを返す必要がある。その「特殊なオブジェクト」には二つのスロットがあって、それは「現在の文脈を引数として受け取り、使用されているレジスタの一覧を返す関数」と「 lvar を受け取り、対応する具象実体を返す関数」からなる。それらは当該構文水準変換時に全ハンドラから参照可能であって、適当なハンドラから呼び出される。

まず、戻り値について。現在の設計では、戻り値はスタックに載せるべきであるが、面倒であるのでレジスタに載せている。スタックに載せるとなると「エピローグ」と「呼び出し結果の利用部分」を修正する必要がある。

次に時系列順に、現在の "plug" による、関数呼び出しを解説しよう。まず、スタックは下に伸びると仮定する。また、ここでいう「引数」と「ローカル変数」の違いであるが、引数とは lambda 式の実パラメータであり「引数割り当て」によって割り当てられる。ローカス変数とは呼び出された関数( callee )における、 let 式などで導入される変数であり、「レジスタ割り当て」で割り当てられる。また「関数を呼び出す側」を caller と呼び、「呼び出された側」を callee と呼ぶ。

具体的なスタックの構造であるが、アドレスが高い順に「一般の退避レジスタ・ caller のフレームポインタ((退避レジスタの一部とも考えられる。))・戻りアドレス・引数・ローカル変数」と並ぶ。

-caller におけるスタック操作(呼び出し時) : caller は引数として与えられた式を全て評価し、実引数を得る((その為の構文変換はA正規化の一部であるが、 Scheme 式が中間言語形式に変換される時点で行われている。))。次に「一般の退避レジスタ・ caller のフレームポインタ・戻りアドレス・引数の為の領域」を確保する。ここでいう「確保 = アロケーション」とは「スタックポインタから定数値をデクリメントすること」である。そして、それらを適切な位置にセットし、 jmp インストラクションによって、 callee へと制御転送する。

-callee におけるスタック操作 : 「プロローグ」では、まず現在のスタックポインタをフレームポインタに代入し、次に callee における全ローカル変数の為の領域をアロケートする(この順序が大切である)。「エピローグ」では callee は全ローカル変数と引数を開放(スタックポインタをインクリメント)し、 ret インストラクションによって、 caller へ戻る。当然ながら ret 実行時には、 0(rsp) は戻りアドレスを指さなければならない。
--なお、 callee は、どうしても揮発性レジスタが足りない場合、スタックの明らかに使用されていない領域に、何らかのレジスタを退避し、揮発性レジスタを得るが、そのことは本質的ではない。また、現在はレジスタが山ほど余っているので、起こり得ない操作であるので、考慮する必要なし。

-caller におけるスタック操作(戻り時) : callee から戻った直後、 0(rsp) は caller 側のフレームポインタを指している。まず 0(rsp) を rbp に代入し、開放する。次に「戻り値」を何らかの変数に代入したり、しなかったりする。そして、最後に退避したレジスタを復帰させ、その為の領域を開放する。
--レジスタ退避で重要なのは「生存区間が当該呼び出しにおいて終了するレジスタを退避してはならない」ということだ。これを忘れると面倒なデバッグがやってくる。

caller/callee における引数の実体化、つまりスタック参照の計算は「引数割り当て」による。「引数割り当て」は caller か callee かを示す引数と共に呼ばれ、適切に割り当てを行い、割り当てられた実体のリストと、スタックポインタの変位の二値を戻す。 caller/callee での差は、参照のベースにスタックポインタを用いるか、フレームポインタを用いるかの違いでしかない。 caller ではスタックポインタを利用する。インストラクションとしては、二者ともフレームポインタを用いた方が高速らしいが、コンパイルが面倒なのでスタックポインタを用いている((そもそも fast call 化と「本物のレジスタ割り当て」を行えば無用の長物になるものに投資する理由はない。わけでもないか……。しかし全部フレームポインタで参照するなら、全部スタックポインタで参照する方が賢いようにも思う。まあ、このあたりの計算を自動化するのが、私の仕事ということだ。))。
